name: Deploy to GKE

on:
  push:
    branches:
      - main

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GAR_LOCATION: us-central1 # Update if you used a different region
  GKE_CLUSTER: sre-portfolio-project-481507-gke # Update with your cluster name
  GKE_ZONE: us-central1 # Update with your cluster region
  DEPLOYMENT_NAME: python-app
  REPOSITORY: sre-repo
  IMAGE: python-app

jobs:
  setup-build-publish-deploy:
    name: Setup, Build, Publish, and Deploy
    runs-on: ubuntu-latest
    
    # Required for Workload Identity Federation: request an OIDC token for authentication.
    permissions:
      contents: 'read'
      id-token: 'write'

    steps:
    # 1. Checkout the repository code so the runner can access the Dockerfile and K8s manifests.
    - name: Checkout
      uses: actions/checkout@v4

    # 2. Authenticate to Google Cloud using Workload Identity Federation (Keyless auth).
    # Exchanges GitHub OIDC token for a Google Service Account access token.
    - id: 'auth'
      name: 'Authenticate to Google Cloud'
      uses: 'google-github-actions/auth@v2'
      with:
        workload_identity_provider: '${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}'
        service_account: '${{ secrets.GCP_SERVICE_ACCOUNT }}'

    # 3. Configure kubectl to talk to our specific GKE cluster.
    # Installs the gke-gcloud-auth-plugin and updates ~/.kube/config.
    - name: Set up GKE credentials
      uses: google-github-actions/get-gke-credentials@v2
      with:
        cluster_name: '${{ env.GKE_CLUSTER }}'
        location: '${{ env.GKE_ZONE }}'

    # 4. Configure Docker to use gcloud as a credential helper for Artifact Registry.
    - name: Docker configuration
      run: |-
        gcloud auth configure-docker ${{ env.GAR_LOCATION }}-docker.pkg.dev

    # 5. Build the Docker image locally on the runner.
    # Tags the image with the unique Git Commit SHA for traceability.
    - name: Build
      run: |-
        docker build \
          --tag "${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE }}:${{ github.sha }}" \
          .

    # 6. Push the newly built image to Google Artifact Registry.
    - name: Publish
      run: |-
        docker push "${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE }}:${{ github.sha }}"

    # 7. Deploy the new image to GKE.
    # We dynamically update the manifest using sed and apply it.
    # This creates the deployment if it doesn't exist, or updates it if it does.
    - name: Deploy
      run: |-
        # Replace the placeholder image in deployment.yaml with the specific SHA tag we just built
        sed -i "s|image: .*|image: ${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${{ env.IMAGE }}:${{ github.sha }}|g" k8s/app/deployment.yaml
        
        # Apply the manifests to the cluster
        kubectl apply -f k8s/app/deployment.yaml
        kubectl apply -f k8s/app/service.yaml
        
        # Wait for the rollout to finish successfully
        kubectl rollout status deployment/$DEPLOYMENT_NAME
        kubectl get services -o wide
